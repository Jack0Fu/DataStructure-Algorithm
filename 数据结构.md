# 数据结构

# 1. 哈希表

#hash table  #散列表

我们为什么想用哈希表？当然是因为用哈希表插入、删除和查找数据的速度非常快，平均时间复杂度为O(1)。

想搞懂哈希表，需要理解两个知识点：

1. 如何选择散列函数
2. 如何解决碰撞问题

## 1.1 散列函数

散列函数的功能是将准备存储的数据元素==关键字==映射成存储空间中的一个==索引==。

讲个故事吧，现在有一排座位，座位号是0-100，要安排100位同学坐到这些位置上。然后，我们有一个需求，根据某位同学的姓名，比如李华，我们想要快速地找到李华所在的那个位置。

然后，聪明的小明就想到了一个方法，100位同学中，有同学姓李，有同学姓王，还有同学姓陈等等，那我们可以根据姓氏来安排位置呀。然后小明做了一张索引表：姓李的同学从位置0开始坐，姓陈的同学从位置10开始坐...==这就是散列函数，这里的数据元素是每一个同学，关键字是每一个同学的姓氏。== 

| 姓氏 | 索引（起始位置） |
| ---- | :--------------: |
| 李   |        0         |
| 陈   |        10        |
| 王   |        20        |
| 林   |        30        |
| ...  |       ...        |

根据该散列函数（索引表），李1坐在位置0上，李2坐在位置1上；陈1坐在位置10上。这样的话，如果我想查找王5坐在哪个位置上，我不需要从位置0开始顺序遍历，只需要从位置20开始顺序查找就好了，这样就会节省查找时间。

一般常用的散列函数有直接定址法、除留余数法、数字分析法、平方取中法和折叠法。

选择散列函数的一个重要指标是**尽可能减少碰撞冲突**。

这里讲一下**除留余数法：**

假设M是散列表的大小，关键字为x的数据元素的散列地址为：
$$
H(x) = x \quad mod \quad  M
$$
比如，我们选择M为95，关键字值为5的散列地址为5%95=5，但是关键字值为5、100、195的元素的散列地址均为5，这就会造成碰撞。

**实践证明，M为素数会使散列地址分布比较均匀。**



## 1.2 解决碰撞

碰撞不可能完全避免，总是可能会出现的，所以我们要想方法来解决碰撞。

再以安排座位为例子，比如李11发现原本安排给姓李的人一共就10个座位0-9，那李11坐在哪呀？

李11首先想到了**线性探测法**：

0-9都被坐满了，那李11就继续往后找空位子就是了，找一个离自己近的位置坐下就好了。这样的话，我们想找李11，就从0开始遍历，一直找下去，中间可能会碰到姓陈的人，但是继续遍历下去，如果遇到空位子还是没有找到李11，说明李11不在座位中。（因为李11肯定会坐在离座位9最近的空位子上）

那么假设李11坐在座位13上，说明陈1、陈2、陈3分别坐在座位10、11和12上，而且他们三个在李11来之前就已经到了并选好了座位。那么，接下来，陈4来了往哪坐呢？陈4一看索引表规则，他应该坐在座位13上，但是他去座位13发现李11已经坐在座位13上了，那么按照线性探测法规则，他继续往后找空位，他坐在了座位14上。

那么，这会导致一个问题：

当李11有事离开位置13后（**相当于删除操作，将李11从散列表中删除**），我们想找陈4，按照索引表他应该坐在座位13上，结果走过去发现座位13是个空位置，那么我们就判定陈4没来？（**相当于查询操作，查询得知陈4不在散列表中**）但是，不对呀，陈4明明还在散列表中的。因此，**采用线性探测法，标准的删除操作是不可实现的**，因为散列表中的每一个单元不仅表示自己，还被用作为解决碰撞时联系其他元素的**占位符**。因此，我们要采用**迟删除**的方法，即将李11所坐的这个位置标记为删除，说明之前有人坐过，而不是完全是个空位子，这样查找的时候不会把座位13当成空位子而漏过了陈4。**在实际的操作中，我们可以将被删除的元素标记为删除，而不是从物理地从表中删去，为了表示这个单元的元素已被删除，可以在每个单元中增加一个字段来表示这个单元是活动的或者是被删除的。**

采用线性探测法的缺点是，经过多次删除操作后，几乎所有的单元都会标记为“已删除的”，这样会降低插入、删除和查找操作的性能。

那为了提高散列表的性能，当被删除的元素过多时，必须重新组织散列表，将这些被删除的元素真正删除，即将表中的活动元素重新散列到一个大小相同的空散列表中。

李11意识到在线性探测法中碰撞会引起连锁反应，使表中形成一些较长的连续被占单元，从而使散列表的性能下降。简单地说，就是如果首先让李1、2、... 、20入座，按照线性探测法，不是会把陈1、2....10的位置全占了嘛？这些连续被占的单元我们称为初始聚焦，这会导致后面陈1的入座和查找变慢，陈1需要从座位10开始遍历到座位20，找到空座位才能坐下，**初始聚焦越长导致插入和查找时所需访问的元素就越多**。

李11想到了一种简单的方法能够消除初始聚焦：**二次探测法**

线性探测法是通过散列函数计算出散列地址H，搜索单元H没有成功，依次尝试H+1，H+2，H+3...H+i, 包括从最后一个位置回绕到第一个位置。

那么二次探测法同样是通过散列函数计算出散列地址H，搜索单元H没有成功，这回换一种思路避免初始聚焦，依次尝试$H+1^2, H+2^2,H+3^2,...,H+i^2$ ，包括从最后一个位置回绕到第一个位置。

很显然，相比于线性探测法，采用二次探测法，散列地址H相同的元素在表中分布更加均匀，不会聚集在一起。

那采用了这么一种方法，我们想要查找一个关键字为x的元素时，同样需要先根据散列函数$H(x)$求出它的散列地址H；

然后先查找单元H，若单元H为空，则说明哈希表中不存在该元素；

若单元H对应的元素恰好为x，则找到了x；

若单元H非空但是对应的元素不是x，那么我们就要依次尝试$H+1^2, H+2^2,H+3^2,...,H+i^2$ ，直到成功找到元素x，如果遇到空单元则说明哈希表中不存在该元素。

**线性探测法和二次探测法均属于闭散列表方法。**

李11还是觉得这样好麻烦啊，按照索引表找到一个位置，还被先来的人占座了。所以，他想到一个更方便的方法：**开散列表**

## 1.3 C++ STL中哈希表的使用

在C++ STL（Standard Template Library）标准模板库中，想要创建哈希表，提高数据插入和查找的速度。一般来说，我们可以使用一种容器：unordered_map 

**unordered_map** :

```c++
//https://zh.cppreference.com/w/cpp/container/unordered_map/
#include <iostream>
#include <unordered_map>
 
int main()
{  
// 简单比较演示
    //创建unordered_map对象example，需要指明key和value所属的类
    std::unordered_map<int,char> example = {{1,'a'},{2,'b'}}; 
 	
    //获得unordered_map对象的一些属性
     example.size() //返回unordered_map中的元素数量
         
    //利用insert函数对unordered_map进行插入操作
    example.insert({3, 'c'});
    
    //利用find函数根据关键字查找unordered_map中对应的元素
    auto search = example.find(2);
    if (search != example.end()) {
        std::cout << "Found " << search->first << " " << search->second << '\n';
    } else {
        std::cout << "Not found\n";
    }
    //输出：Found 2 b
    
    //利用erase函数进行删除操作
    for(auto it = c.begin(); it != c.end(); )
        if(it->first % 2 == 1)
            it = c.erase(it);
        else
            ++it;
	}
```

看到unordered_map的代码，大家肯定有一个疑问：我们存入哈希表中的数据格式是键值对**key : value**

那在C++的底层是怎么操作的呢？**如何根据我们所给数据中的key找到对应的散列地址呢？**

**在unordered_map中插入键值对的基本流程是：**

- 先用一个哈希函数将key变成一个哈希值；// **std::hash** <https://en.cppreference.com/w/cpp/utility/hash>

- 根据该哈希值和散列函数，得到散列地址；（一般采用除留余数法）
- 将键值对 key ：value写入该散列地址下

我们还会想到另外一个容器:   **map**

==map和unordered_map的主要区别是啥？==

**unordered_map对应的数据结构是哈希表，而map对应的数据结构是红黑树，两者是不一样的。**

简单的来说，unordered_map是无序的，插入查找数据的速度更快，即时间复杂度更小，为O(1)线性时间，但是空间复杂度较高，即占据的内存较多； 而map是有序的，占的内存较小，空间复杂度，但是插入查找数据的速度较慢，时间复杂度高，为O(logN)。

因此，对于时间复杂要求高的话就使用哈希表unordered_map，而对空间复杂度要求高的话就使用红黑树map。

**reference：**

- <https://zh.cppreference.com/w/cpp/container/unordered_map>
- <https://zh.cppreference.com/w/cpp/container/map>

- <https://www.sczyh30.com/posts/C-C/cpp-stl-hashmap/>
- <https://blog.csdn.net/u010025211/article/details/46653519>
- <https://blog.csdn.net/ajianyingxiaoqinghan/article/details/78542932>

# 2. 排序算法

<https://www.cnblogs.com/onepixel/p/7674659.html>  



